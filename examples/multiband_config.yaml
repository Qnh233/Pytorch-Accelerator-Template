experiment:
  name: "demo_multiband_resnet"
  output_dir: "./outputs/demo_multiband"
  seed: 42

data:
  # Using FakeMultiBandDataset defined in test script or we need to register it
  # For configuration sake, we assume a dataset that returns dict {'rgb': ..., 'sar': ...}
  name: "FakeMultiBandDataset"
  data_params:
    size: 20
  data_loader_params:
    batch_size: 4
    num_workers: 0

model:
  name: "ImageClassifier"

  # 1. Adapter: Extracts 'rgb' (3ch) and 'sar' (1ch) and concats -> 4ch
  adapter:
    type: "ConcatAdapter"
    keys: ["rgb", "sar"]
    dim: 1

  # 2. Stem: Maps 4ch -> 64ch (ResNet standard input)
  stem:
    type: "ConvStem"
    in_channels: 4
    out_channels: 64 # Match ResNet conv1 input?
    # Wait, ResNet conv1 expects 3 channels usually.
    # If we use `ConvStem`, it outputs 64 channels.
    # But ResNet.conv1 takes 3 channels.
    # IF we want to use standard ResNet, we should map to 3?
    # OR we replace ResNet's first layer?
    # Current design: Stem Output -> Backbone Input.
    # If ResNet starts with `nn.Conv2d(3, 64, ...)`, then Stem MUST output 3 channels.
    # Let's map 4 -> 3 for now to keep ResNet untouched.
    out_channels: 3

  backbone:
    type: "ResNet"
    depth: 18
    pretrained: false

  head:
    type: "ClassificationHead"
    in_channels: 512
    num_classes: 2

optimizer:
  name: "Adam"
  params:
    lr: 0.001

training:
  epochs: 1
  eval_every: 1
  mixed_precision: "no"
  log_grad_norm: true

loss:
  name: "CrossEntropyLoss"

callbacks:
  - name: "ProgressLogger"
